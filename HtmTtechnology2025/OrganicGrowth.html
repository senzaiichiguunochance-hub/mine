<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>有機的な成長のキャンバス</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        /* 全体のスタイル設定 */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510; /* 深い宇宙のような背景 */
            cursor: crosshair; /* 十字カーソルでインタラクションを強調 */
            font-family: 'Inter', sans-serif;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        /* キャンバスのスタイル設定 */
        canvas {
            display: block;
            border-radius: 20px;
            box-shadow: 0 0 80px rgba(100, 200, 255, 0.6), 0 0 30px rgba(255, 255, 255, 0.3); /* より幻想的な光 */
            background-color: rgba(0, 0, 0, 0.15); /* わずかに透明なキャンバス */
            touch-action: none; /* タッチジェスチャーの無効化 */
            max-width: 100vw; /* 画面幅にフィット */
            max-height: 100vh; /* 画面高さにフィット */
            width: auto; /* 幅を自動調整 */
            height: auto; /* 高さを自動調整 */
        }

        /* メッセージ表示用のスタイル */
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.6);
            padding: 12px 25px;
            border-radius: 15px;
            font-size: 1.2em;
            text-align: center;
            opacity: 0.9;
            transition: opacity 0.5s ease-in-out;
            z-index: 10;
            backdrop-filter: blur(5px); /* 背景をぼかす */
            box-shadow: 0 0 15px rgba(0, 200, 255, 0.3); /* 光る枠 */
        }
    </style>
</head>
<body>
    <canvas id="organicCanvas"></canvas>
    <div id="instructions">クリック後にマウスを動かして、形状の変化を楽しもう！</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script>
        // キャンバス要素と描画コンテキストを取得
        const canvas = document.getElementById('organicCanvas');
        const ctx = canvas.getContext('2d');
        const instructionsDiv = document.getElementById('instructions');

        // 成長する枝のノードを格納する配列
        const nodes = [];

        // 音声コンテキストとシンセサイザーの設定
        let audioContextStarted = false;
        const synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: {
                attack: 0.05,
                decay: 0.2,
                sustain: 0.5,
                release: 1,
            },
            volume: -15 // 音量を少し小さめに設定
        }).toDestination();
        const reverb = new Tone.Reverb(2).toDestination(); // リバーブエフェクト
        synth.connect(reverb);

        // Nodeクラスの定義（成長する枝の各点）
        class Node {
            constructor(x, y, parent = null, level = 0, hue) {
                this.x = x;
                this.y = y;
                this.parent = parent; // 親ノード
                this.level = level; // 成長の段階（深さ）
                this.hue = hue; // 色相
                this.age = 0; // ノードの年齢
                this.maxAge = 200 + Math.random() * 100; // ノードの最大寿命
                this.branches = []; // このノードから分岐した子ノード
                this.isRoot = (parent === null); // ルートノードかどうか
            }

            // ノードを更新するメソッド
            update() {
                this.age++;
                // 古いノードは徐々に透明度を下げる
                if (this.age > this.maxAge * 0.7) {
                    // 何もしない（描画時にalphaを計算）
                }
            }

            // ノードとそれに続く枝を描画するメソッド
            draw() {
                if (this.parent) {
                    const alpha = Math.max(0, 1 - (this.age / this.maxAge)); // 寿命に応じた透明度
                    const thickness = Math.max(0.5, 3 - this.level * 0.2); // 深さに応じた太さ

                    ctx.strokeStyle = `hsla(${this.hue}, 100%, 70%, ${alpha})`;
                    ctx.lineWidth = thickness;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.parent.x, this.parent.y);
                    ctx.lineTo(this.x, this.y);
                    ctx.stroke();
                }
            }
        }

        // 新しい成長の「種」を追加する関数
        const addGrowthSeed = (x, y) => {
            const newHue = (Math.random() * 360); // 新しい成長の色相
            const rootNode = new Node(x, y, null, 0, newHue);
            nodes.push(rootNode);

            // サウンドを再生
            if (audioContextStarted) {
                synth.triggerAttackRelease(Tone.Frequency(newHue * 2).toNote(), '8n'); // 色相に対応した音
            }
        };

        // 既存のノードから新たな枝を分岐させる関数
        const branchOut = () => {
            if (!audioContextStarted) return; // 音声コンテキストが開始されていない場合は何もしない

            // アクティブなノード（寿命が残っているノード）のみを対象
            const activeNodes = nodes.filter(node => node.age < node.maxAge);

            activeNodes.forEach(node => {
                // ランダムに枝を伸ばすかどうかを決定
                if (Math.random() < 0.05 && node.level < 8) { // 深さ制限
                    const angle = Math.random() * Math.PI * 2; // ランダムな方向
                    const length = Math.random() * 30 + 10; // 枝の長さ

                    const newX = node.x + Math.cos(angle) * length;
                    const newY = node.y + Math.sin(angle) * length;

                    // 画面内に収まるように調整
                    if (newX > 0 && newX < canvas.width && newY > 0 && newY < canvas.height) {
                        const newHue = (node.hue + (Math.random() - 0.5) * 60 + 360) % 360; // 色相を微調整
                        const newNode = new Node(newX, newY, node, node.level + 1, newHue);
                        nodes.push(newNode);

                        // サウンドを再生
                        //synth.triggerAttackRelease(Tone.Frequency(newNode.hue + 100).toNote(), '16n'); // 新しい枝の音
                    }
                }
            });
        };

        // キャンバスのサイズをウィンドウに合わせる関数
        const resizeCanvas = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // リサイズ時に既存のノードの位置を画面サイズに合わせて調整することも可能ですが、
            // 今回は単純にクリアして新しい成長を促します
            nodes.length = 0; // リサイズ時に既存のノードをクリア
        };

        // ウィンドウのリサイズイベントを監視
        window.addEventListener('resize', resizeCanvas);
        // 最初のロード時にキャンバスサイズを設定
        resizeCanvas();

        // マウスのクリックイベントで成長の種を蒔く
        canvas.addEventListener('click', (e) => {
            // Web Audio APIのコンテキストをユーザー操作で開始
            if (!audioContextStarted) {
                Tone.start().then(() => {
                    audioContextStarted = true;
                    instructionsDiv.textContent = 'クリック後にマウスを動かして、形状の変化を楽しもう！';
                    instructionsDiv.style.opacity = 0.5;
                });
            }
            addGrowthSeed(e.clientX, e.clientY);
        });

        // マウスの動きに合わせて枝を分岐させる
        canvas.addEventListener('mousemove', (e) => {
            // マウスの動きがあるたびに、既存のノードから分岐を試みる
            branchOut();
        });

        // タッチイベントの処理 (モバイルデバイス対応)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (!audioContextStarted) {
                Tone.start().then(() => {
                    audioContextStarted = true;
                    instructionsDiv.textContent = '指を動かして、生命のパターンを育もう！';
                    instructionsDiv.style.opacity = 0.5;
                });
            }
            const touch = e.touches[0];
            addGrowthSeed(touch.clientX, touch.clientY);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            branchOut(); // タッチ移動でも分岐を試みる
        }, { passive: false });


        // アニメーションループ
        const animate = () => {
            // 古い描画を徐々に消すことで、残像効果（トレイル）を作成
            ctx.fillStyle = 'rgba(5, 5, 16, 0.08)'; /* 背景色と同じ色で薄く上書き */
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ノードを更新し、寿命が尽きたものを削除
            for (let i = nodes.length - 1; i >= 0; i--) {
                const node = nodes[i];
                node.update();
                node.draw(); // 描画

                if (node.age > node.maxAge && node.branches.length === 0) {
                    // 寿命が尽きて、かつ子ノードがない場合は削除
                    nodes.splice(i, 1);
                }
            }

            // 定期的に新しい枝を伸ばす機会を与える
            if (Math.random() < 0.1) { // 10%の確率で毎フレーム分岐を試みる
                branchOut();
            }

            requestAnimationFrame(animate); // 次のフレームを要求
        };

        // アニメーションを開始
        animate();
    </script>
</body>
</html>
