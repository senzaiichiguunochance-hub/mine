<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>無限の波紋の池</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        /* 全体のスタイル設定 */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #02020a; /* より深い、暗い背景 */
            cursor: none; /* カーソルを非表示にして没入感を高める */
            font-family: 'Inter', sans-serif;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        /* キャンバスのスタイル設定 */
        canvas {
            display: block;
            border-radius: 25px; /* さらに丸みを帯びた角 */
            box-shadow: 0 0 100px rgba(150, 200, 255, 0.7), 0 0 40px rgba(255, 255, 255, 0.4); /* 強く光る影 */
            background-color: rgba(0, 0, 0, 0.2); /* わずかに透明なキャンバス */
            touch-action: none; /* タッチジェスチャーの無効化 */
            width: 100vw; /* 画面幅いっぱいに広がる */
            height: 100vh; /* 画面高さいっぱいに広がる */
        }

        /* メッセージ表示用のスタイル */
        #instructions {
            position: absolute;
            top: 25px; /* 下部に配置 */
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 20px;
            font-size: 1.3em;
            text-align: center;
            opacity: 0.95;
            transition: opacity 0.8s ease-in-out;
            z-index: 10;
            backdrop-filter: blur(8px); /* 強い背景ぼかし */
            box-shadow: 0 0 20px rgba(50, 255, 255, 0.4); /* 青緑系の光る枠 */
        }
    </style>
</head>
<body>
    <canvas id="weaveCanvas"></canvas>
    <div id="instructions">マウスを動かし、クリックして形を楽しもう！</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <script>
        // キャンバス要素と描画コンテキストを取得
        const canvas = document.getElementById('weaveCanvas');
        const ctx = canvas.getContext('2d');
        const instructionsDiv = document.getElementById('instructions');

        let animationFrameId; // requestAnimationFrame IDを格納し、必要に応じてキャンセルできるようにする
        let audioContextStarted = false;

        // Tone.jsシンセサイザーとエフェクトのセットアップ
        const synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "triangle" }, // より柔らかい音色
            envelope: {
                attack: 0.5,
                decay: 1,
                sustain: 0.7,
                release: 2,
            },
            volume: -25 // 音量をさらに小さくしてアンビエントな雰囲気にする
        }).toDestination();
        const reverb = new Tone.Reverb(4).toDestination(); // 長めのリバーブ
        const delay = new Tone.FeedbackDelay("4n", 0.6).toDestination(); // 豊かなディレイ
        synth.chain(delay, reverb, Tone.Destination);

        // 音を鳴らすためのスケール（ペンタトニックスケールを使用）
        const scale = ["C3", "D3", "E3", "G3", "A3", "C4", "D4", "E4", "G4", "A4"];
        let currentScaleIndex = 0;

        // Tone.Loopで定期的に音を鳴らす
        let noteLoop = null;

        // WeaverOscillatorクラス: 円周上を動く点
        class WeaverOscillator {
            constructor(centerX, centerY, radius, frequency, phaseOffset, hue) {
                this.centerX = centerX; // 円の中心X座標
                this.centerY = centerY; // 円の中心Y座標
                this.radius = radius; // 円の半径
                this.frequency = frequency; // 回転速度（周波数）
                this.phaseOffset = phaseOffset; // 位相オフセット
                this.currentAngle = 0; // 現在の角度
                this.currentX = centerX; // 現在のX座標
                this.currentY = centerY; // 現在のY座標
                this.hue = hue; // 描画の色相
            }

            // オシレーターの状態を更新
            update(time) {
                this.currentAngle = (time * this.frequency + this.phaseOffset) % (Math.PI * 2);
                this.currentX = this.centerX + Math.cos(this.currentAngle) * this.radius;
                this.currentY = this.centerY + Math.sin(this.currentAngle) * this.radius;
            }

            // 現在の位置を取得
            getPosition() {
                return { x: this.currentX, y: this.currentY };
            }
        }

        // アニメーションのフレーム数カウンター
        let frameCount = 0;
        // グローバルな色相オフセット
        let globalHue = 0;

        // オシレーターのインスタンスを格納する配列
        const weavers = [];
        // オシレーター間の接続を定義
        const connections = [];

        // 初期化関数
        const initializeWeavers = () => {
            weavers.length = 0; // 既存のオシレーターをクリア
            connections.length = 0; // 既存の接続をクリア

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxDim = Math.min(canvas.width, canvas.height) * 0.4; // 画面サイズの40%を最大半径に

            // 4つのオシレーターを生成
            weavers.push(new WeaverOscillator(centerX, centerY, maxDim * 0.8, 0.005 + Math.random() * 0.005, Math.random() * Math.PI * 2, 0));
            weavers.push(new WeaverOscillator(centerX, centerY, maxDim * 0.6, 0.007 + Math.random() * 0.005, Math.random() * Math.PI * 2, 60));
            weavers.push(new WeaverOscillator(centerX, centerY, maxDim * 0.4, 0.009 + Math.random() * 0.005, Math.random() * Math.PI * 2, 120));
            weavers.push(new WeaverOscillator(centerX, centerY, maxDim * 0.2, 0.011 + Math.random() * 0.005, Math.random() * Math.PI * 2, 180));

            // オシレーター間の接続を定義 (ここではすべての隣接するオシレーターを接続)
            for (let i = 0; i < weavers.length; i++) {
                for (let j = i + 1; j < weavers.length; j++) {
                    connections.push({ from: i, to: j });
                }
            }
        };

        // キャンバスのサイズをウィンドウに合わせる関数
        const resizeCanvas = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            // リサイズ時にパターンをリセット
            initializeWeavers();
        };

        // ウィンドウのリサイズイベントを監視
        window.addEventListener('resize', resizeCanvas);
        // 最初のロード時にキャンバスサイズとオシレーターを設定
        resizeCanvas();

        // アニメーションループ
        const animate = () => {
            // 背景をゆっくりとフェードアウトさせることで、残像効果を生み出す
            ctx.fillStyle = 'rgba(2, 2, 10, 0.03)'; // わずかに透明な背景でトレイル効果
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            frameCount++;
            globalHue = (globalHue + 0.1) % 360; // 色相をゆっくり変化させる

            // オシレーターを更新
            weavers.forEach(osc => osc.update(frameCount));

            // 接続を描画
            connections.forEach(conn => {
                const osc1 = weavers[conn.from];
                const osc2 = weavers[conn.to];

                const pos1 = osc1.getPosition();
                const pos2 = osc2.getPosition();

                ctx.strokeStyle = `hsla(${(globalHue + osc1.hue) % 360}, 100%, 70%, 0.8)`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(pos1.x, pos1.y);
                ctx.lineTo(pos2.x, pos2.y);
                ctx.stroke();
            });

            animationFrameId = requestAnimationFrame(animate); // 次のフレームを要求
        };

        // マウスの動きでパターンを微妙に変化させる
        canvas.addEventListener('mousemove', (e) => {
            if (!audioContextStarted) return; // 音声コンテキストが開始されていない場合は何もしない

            // マウスY座標に応じて一番外側のオシレーターの半径を調整
            const newRadiusFactor = (e.clientY / canvas.height) * 0.6 + 0.2; // 0.2から0.8の範囲
            weavers[0].radius = Math.min(canvas.width, canvas.height) * newRadiusFactor;

            // マウスX座標に応じて特定のオシレーターの周波数を調整
            const newFreqFactor = (e.clientX / canvas.width) * 0.005 + 0.002; // 0.002から0.007の範囲
            weavers[1].frequency = 0.007 + newFreqFactor;
        });

        // クリックでパターンをリセットし、サウンドを再生
        canvas.addEventListener('click', (e) => {
            // Web Audio APIのコンテキストをユーザー操作で開始
            if (!audioContextStarted) {
                Tone.start().then(() => {
                    audioContextStarted = true;
                    instructionsDiv.textContent = 'マウスを動かし、クリックして形を楽しもう！';
                    instructionsDiv.style.opacity = 0.5;

                    // 音声ループを開始
                    noteLoop = new Tone.Loop(time => {
                        const note = scale[currentScaleIndex % scale.length];
                        synth.triggerAttackRelease(note, "2n", time); // 長めの音
                        currentScaleIndex = (currentScaleIndex + 1) % scale.length;
                    }, "2n").start(0); // 2秒ごとに音を鳴らす
                });
            } else {
                // 音声ループが既に開始されている場合、停止して新しいループを開始し、パターンをリセット
                if (noteLoop) {
                    noteLoop.stop();
                }
                noteLoop = new Tone.Loop(time => {
                    const note = scale[currentScaleIndex % scale.length];
                    synth.triggerAttackRelease(note, "2n", time); // 長めの音
                    currentScaleIndex = (currentScaleIndex + 1) % scale.length;
                }, "2n").start(0); // 2秒ごとに音を鳴らす
            }
            initializeWeavers(); // パターンをリセット
        });

        // タッチイベントの処理 (モバイルデバイス対応)
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            // Web Audio APIのコンテキストをユーザー操作で開始
            if (!audioContextStarted) {
                Tone.start().then(() => {
                    audioContextStarted = true;
                    instructionsDiv.textContent = 'パターンの進化を楽しもう！';
                    instructionsDiv.style.opacity = 0.5;

                    noteLoop = new Tone.Loop(time => {
                        const note = scale[currentScaleIndex % scale.length];
                        synth.triggerAttackRelease(note, "2n", time);
                        currentScaleIndex = (currentScaleIndex + 1) % scale.length;
                    }, "2n").start(0);
                });
            } else {
                if (noteLoop) {
                    noteLoop.stop();
                }
                noteLoop = new Tone.Loop(time => {
                    const note = scale[currentScaleIndex % scale.length];
                    synth.triggerAttackRelease(note, "2n", time);
                    currentScaleIndex = (currentScaleIndex + 1) % scale.length;
                }, "2n").start(0);
            }
            initializeWeavers(); // パターンをリセット
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            // マウスY座標に応じて一番外側のオシレーターの半径を調整
            const newRadiusFactor = (touch.clientY / canvas.height) * 0.6 + 0.2; // 0.2から0.8の範囲
            weavers[0].radius = Math.min(canvas.width, canvas.height) * newRadiusFactor;

            // マウスX座標に応じて特定のオシレーターの周波数を調整
            const newFreqFactor = (touch.clientX / canvas.width) * 0.005 + 0.002; // 0.002から0.007の範囲
            weavers[1].frequency = 0.007 + newFreqFactor;
        }, { passive: false });


        // アニメーションを開始
        animate();
    </script>
</body>
</html>
