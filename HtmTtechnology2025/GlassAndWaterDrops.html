<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>水中インク（改良版）</title>
<style>
  html,body{height:100%;margin:0;background:#dff0fb;}
  canvas{display:block; width:100vw; height:100vh; cursor:crosshair;}
  #ui{position:fixed;left:10px;top:10px;z-index:20;background:rgba(255,255,255,0.85);padding:8px;border-radius:8px;font-family:system-ui;}
  label{margin-right:8px;font-size:13px}
</style>
</head>
<body>
<canvas id="cv"></canvas>
<div id="ui">
  <label>色<input id="col" type="color" value="#ff2166"></label>
  <label>濃さ<input id="dens" type="range" min="0.5" max="3" step="0.1" value="1.2"></label>
  <label>にじみ<input id="fade" type="range" min="0.92" max="0.995" step="0.001" value="0.98"></label>
  <button id="clear">クリア</button>
</div>

<script>
/* 改良ポイント（短く）
 - Perlinノイズで滑らかな横揺れを生成
 - Verlet積分＋距離制約でセグメントを柔らかく繋ぐ（糸っぽさ）
 - 各セグメントを個別に太さを変えて短い線を重ね描画（先端細め）
 - 半透明・lighter合成・shadowBlurで水中のにじみ感
*/

const canvas = document.getElementById('cv');
const ctx = canvas.getContext('2d');
const buf = { w:0,h:0 };
function resize(){
  canvas.width = innerWidth; canvas.height = innerHeight;
  buf.w = canvas.width; buf.h = canvas.height;
}
addEventListener('resize', resize);
resize();

const colorInput = document.getElementById('col');
const densityInput = document.getElementById('dens');
const fadeInput = document.getElementById('fade');
document.getElementById('clear').addEventListener('click', () => {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#dff0fb'; ctx.fillRect(0,0,canvas.width,canvas.height);
});

ctx.fillStyle = '#dff0fb'; ctx.fillRect(0,0,canvas.width,canvas.height);

/* --- Perlin noise (2D) --- */
// classic permutation
const p_orig = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,
  136,171,168, 68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,
  41,55,46,245,40,244,102,143,54,65,25,63,161, 1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,
  188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,
  59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,
  129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,
  179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184, 84,204,176,115,121,50,45,127,4,150,
  254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
const perm = new Uint8Array(512);
for(let i=0;i<512;i++) perm[i] = p_orig[i & 255];

function fade(t){ return t*t*t*(t*(t*6-15)+10); }
function lerp(a,b,t){ return a + t*(b-a); }
function grad(hash, x, y){
  const h = hash & 3;
  const u = h < 2 ? x : y;
  const v = h < 2 ? y : x;
  return ((h & 1) ? -u : u) + ((h & 2) ? -2*v : 2*v);
}
function perlin2(x,y){
  // grid cell coords
  const X = Math.floor(x) & 255;
  const Y = Math.floor(y) & 255;
  const xf = x - Math.floor(x);
  const yf = y - Math.floor(y);
  const u = fade(xf);
  const v = fade(yf);
  const aa = perm[X+perm[Y]];
  const ab = perm[X+perm[Y+1]];
  const ba = perm[X+1+perm[Y]];
  const bb = perm[X+1+perm[Y+1]];
  const x1 = lerp(grad(aa, xf, yf), grad(ba, xf-1, yf), u);
  const x2 = lerp(grad(ab, xf, yf-1), grad(bb, xf-1, yf-1), u);
  return lerp(x1, x2, v) * 0.5; // roughly -1..1 scaled
}

/* --- Strand (柔らかい糸) --- */
class Strand {
  constructor(x,y,color,segments,segLen,baseWidth){
    this.color = color;
    this.segLen = segLen;
    this.baseWidth = baseWidth;
    this.segs = [];
    this.age = 0;
    this.maxLife = 12000; // long-lived; we'll remove by offscreen
    this.noiseSeed = Math.random()*1000;
    for(let i=0;i<segments;i++){
      const px = x + (Math.random()-0.5)*2;
      const py = y + i*segLen + (Math.random()*2);
      this.segs.push({ x: px, y: py, px: px, py: py });
    }
  }
  update(dt, t){
    this.age += dt;
    const g = 0.0009 * dt; // gravity scaled
    const damp = 0.995;
    // head: apply Perlin lateral acceleration + gravity
    const head = this.segs[0];
    // compute noise from position & time for smooth lateral force
    const nx = perlin2(head.x*0.006, (t+this.noiseSeed)*0.0008);
    const ny = perlin2(head.x*0.002+50, (t+this.noiseSeed)*0.0006);
    // Verlet integration
    let vx = (head.x - head.px) * damp;
    let vy = (head.y - head.py) * damp;
    head.px = head.x; head.py = head.y;
    head.x += vx + nx * 0.6 * dt * 0.02;
    head.y += vy + (g + ny * 0.08) * dt * 0.02;

    // other segments: slight noise + follow
    for(let i=1;i<this.segs.length;i++){
      const s = this.segs[i];
      let vxi = (s.x - s.px) * damp;
      let vyi = (s.y - s.py) * damp;
      s.px = s.x; s.py = s.y;
      // small lateral modifier for more curling
      const n = perlin2(s.x*0.006, (t+this.noiseSeed + i*7)*0.0009);
      s.x += vxi + n * 0.2 * dt * 0.02;
      s.y += vyi + g * dt * 0.02;
    }

    // constraint solver: keep segment distances close to segLen (iterate few times)
    const iter = 3;
    for(let k=0;k<iter;k++){
      for(let i=1;i<this.segs.length;i++){
        const a = this.segs[i-1];
        const b = this.segs[i];
        let dx = b.x - a.x;
        let dy = b.y - a.y;
        let dist = Math.hypot(dx,dy) || 0.0001;
        const diff = (dist - this.segLen) / dist;
        const adjustX = dx * diff * 0.5;
        const adjustY = dy * diff * 0.5;
        // move both points (soft)
        a.x += adjustX;
        a.y += adjustY;
        b.x -= adjustX;
        b.y -= adjustY;
      }
    }
  }

  draw(ctx){
    const pts = this.segs;
    const n = pts.length;
    if(n < 2) return;
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    // small glow
    ctx.shadowBlur = Math.max(2, this.baseWidth*2.5);
    ctx.shadowColor = this.color;
    // draw short segments with varying width to simulate taper
    for(let i=0;i<n-1;i++){
      const p1 = pts[i], p2 = pts[i+1];
      const t = i / (n-1);
      // width: base at top -> thinner toward tip (逆に写真は先端が濃いので少し変化)
      const w = this.baseWidth * (1 - Math.pow(t, 1.2)) + 0.4;
      // alpha: 内側を濃く、外側薄く
      const alpha = Math.min(1, 0.9 * (1 - t) + 0.15);
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.lineWidth = w;
      // create rgba from hex color
      ctx.strokeStyle = colorWithAlpha(this.color, alpha);
      ctx.stroke();
    }
    // tip droplet
    const tip = pts[n-1];
    ctx.beginPath();
    ctx.fillStyle = colorWithAlpha(this.color, 0.95);
    ctx.globalAlpha = 0.95;
    ctx.arc(tip.x, tip.y, Math.max(0.6, this.baseWidth*0.8), 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  isDead(w,h){
    // if all segments out of screen and age sufficiently large -> dead
    if(this.age < 400) return false;
    for(let p of this.segs){
      if(p.x > -50 && p.x < w+50 && p.y > -50 && p.y < h+50) return false;
    }
    return true;
  }
}

function colorWithAlpha(hex, a){
  // hex like #rrggbb
  if(hex[0]==='#') hex = hex.slice(1);
  const r = parseInt(hex.slice(0,2),16);
  const g = parseInt(hex.slice(2,4),16);
  const b = parseInt(hex.slice(4,6),16);
  return `rgba(${r},${g},${b},${a})`;
}

/* --- orchestration --- */
const strands = [];
let last = performance.now();
function spawn(x,y){
  const density = parseFloat(densityInput.value);
  const count = Math.round(6 * density); // strands per click
  const baseColor = colorInput.value;
  for(let i=0;i<count;i++){
    // each strand with random length & width
    const segs = Math.floor(rand(22, 48) * (1 + Math.random()*0.3));
    const segLen = rand(2.2, 3.8);
    const w = rand(1.2, 3.2) * (1 + (density-1)*0.6);
    const sx = x + rand(-6,6);
    const sy = y + rand(-4,10);
    const s = new Strand(sx, sy, baseColor, segs, segLen, w);
    // small initial downward bias
    s.segs[0].px -= rand(-0.6,0.6); s.segs[0].py -= rand(1.2,2.8);
    strands.push(s);
  }
}

canvas.addEventListener('pointerdown', (ev) => {
  spawn(ev.clientX, ev.clientY);
});

// demo spawn center
spawn(innerWidth*0.45, innerHeight*0.18);

function loop(now){
  const dt = Math.min(40, now - last);
  last = now;

  // fade background slightly (にじみ). fadeInput controls how strong background remains
  const fade = parseFloat(fadeInput.value);
  ctx.fillStyle = `rgba(214,236,248,${1 - fade})`;
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // update/draw
  for(let i = strands.length - 1; i >= 0; i--){
    const s = strands[i];
    s.update(dt, now);
    s.draw(ctx);
    if(s.isDead(canvas.width, canvas.height)) strands.splice(i,1);
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function rand(a,b){ return Math.random()*(b-a)+a; }
</script>
</body>
</html>
